<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Real-time Face Anti-Spoofing Detection</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f0f0f0;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
      }
      .video-container {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        position: relative;
      }
      #videoFeed {
        border: 2px solid #333;
        border-radius: 10px;
        max-width: 100%;
        height: auto;
        display: none;
      }
      #cameraVideo {
        border: 2px solid #333;
        border-radius: 10px;
        max-width: 640px;
        width: 100%;
        height: auto;
        display: none;
      }
      #canvas {
        display: none;
      }
      .session-info {
        background-color: #e3f2fd;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
        border-left: 4px solid #2196f3;
      }
      .offline-indicator {
        background-color: #ffebee;
        color: #c62828;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
        border-left: 4px solid #f44336;
        display: none;
      }
      .controls {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
      }
      button {
        padding: 10px 20px;
        font-size: 16px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
      }
      .start-btn {
        background-color: #4caf50;
        color: white;
      }
      .start-btn:hover {
        background-color: #45a049;
      }
      .stop-btn {
        background-color: #f44336;
        color: white;
      }
      .stop-btn:hover {
        background-color: #da190b;
      }
      .status-panel {
        background-color: #f9f9f9;
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
      }
      .status-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        padding: 10px;
        background-color: white;
        border-radius: 5px;
        border-left: 4px solid #ddd;
      }
      .status-item.real {
        border-left-color: #4caf50;
      }
      .status-item.fake {
        border-left-color: #f44336;
      }
      .status-label {
        font-weight: bold;
      }
      .status-value {
        color: #666;
      }
      .confidence-bar {
        width: 100%;
        height: 20px;
        background-color: #ddd;
        border-radius: 10px;
        overflow: hidden;
        margin-top: 10px;
      }
      .confidence-fill {
        height: 100%;
        transition: width 0.3s ease;
      }
      .real-confidence {
        background-color: #4caf50;
      }
      .fake-confidence {
        background-color: #f44336;
      }
      .instructions {
        background-color: #e7f3ff;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
        border-left: 4px solid #2196f3;
      }
      .error {
        background-color: #ffebee;
        color: #c62828;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
        border-left: 4px solid #f44336;
      }
      .nav-link {
        display: inline-block;
        margin-bottom: 20px;
        color: #2196f3;
        text-decoration: none;
      }
      .nav-link:hover {
        text-decoration: underline;
      }
      .task-panel {
        background-color: #e8f4fd;
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
        border-left: 4px solid #2196f3;
      }
      .task-active {
        background-color: #fff3e0;
        border-left-color: #ff9800;
        animation: pulse 2s infinite;
      }
      .task-completed {
        background-color: #e8f5e8;
        border-left-color: #4caf50;
      }
      .task-failed {
        background-color: #ffebee;
        border-left-color: #f44336;
      }
      @keyframes pulse {
        0% {
          background-color: #fff3e0;
        }
        50% {
          background-color: #ffe0b2;
        }
        100% {
          background-color: #fff3e0;
        }
      }
      .task-controls {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
      }
      .task-btn {
        background-color: #ff9800;
        color: white;
      }
      .task-btn:hover {
        background-color: #f57c00;
      }
      .reset-btn {
        background-color: #9e9e9e;
        color: white;
      }
      .reset-btn:hover {
        background-color: #757575;
      }
      .task-progress {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      .task-timer {
        font-size: 18px;
        font-weight: bold;
        color: #ff9800;
      }
      .task-instruction {
        font-size: 20px;
        font-weight: bold;
        color: #2196f3;
        text-align: center;
        margin: 15px 0;
      }
      .task-list {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin: 10px 0;
      }
      .task-item {
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 12px;
        background-color: #f0f0f0;
        border: 1px solid #ddd;
      }
      .task-item.completed {
        background-color: #4caf50;
        color: white;
      }
      .task-item.current {
        background-color: #ff9800;
        color: white;
        animation: blink 1s infinite;
      }
      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0.5;
        }
      }
      .anti-spoof-panel {
        background-color: #f3e5f5;
        padding: 15px;
        border-radius: 5px;
        margin-top: 15px;
        border-left: 4px solid #9c27b0;
      }
      .anti-spoof-failed {
        background-color: #ffebee;
        border-left-color: #f44336;
      }
      .anti-spoof-passed {
        background-color: #e8f5e8;
        border-left-color: #4caf50;
      }
      .validation-details {
        font-size: 12px;
        margin-top: 10px;
        color: #666;
      }
      .final-result {
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        padding: 15px;
        border-radius: 5px;
        margin: 15px 0;
      }
      .final-result.passed {
        background-color: #4caf50;
        color: white;
      }
      .final-result.failed {
        background-color: #f44336;
        color: white;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <a href="/" class="nav-link">‚Üê Back to File Upload</a>

      <h1>Real-time Face Anti-Spoofing Detection</h1>

      <div class="session-info" id="sessionInfo" style="display: none">
        <h3>Session Information:</h3>
        <p>
          <strong>Session ID:</strong> <span id="sessionId">Not connected</span>
        </p>
        <p><strong>Status:</strong> <span id="sessionStatus">Inactive</span></p>
        <p>
          <strong>Camera Access:</strong>
          <span id="cameraAccess">Not granted</span>
        </p>
      </div>

      <div class="instructions">
        <h3>Instructions:</h3>
        <ul>
          <li>Click "Start Camera" to begin real-time detection</li>
          <li>Grant camera permissions when prompted</li>
          <li>Position your face clearly in front of the camera</li>
          <li>
            Ensure only ONE face is visible (multiple faces will terminate
            session)
          </li>
          <li>
            The system will automatically detect if the face is real or fake
          </li>
          <li>Green indicators show real face, red shows fake face</li>
          <li>Click "Stop Camera" when finished</li>
        </ul>
      </div>

      <div class="controls">
        <button class="start-btn" onclick="startCamera()">Start Camera</button>
        <button class="task-btn" onclick="startLivenessTask()">
          Start Liveness Test
        </button>
        <button class="reset-btn" onclick="resetTaskSession()">
          Reset Tasks
        </button>
        <button class="stop-btn" onclick="stopCamera()">Stop Camera</button>
      </div>

      <div class="video-container">
        <video id="cameraVideo" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
        <img
          id="videoFeed"
          src=""
          alt="Video feed will appear here"
          style="display: none"
        />
      </div>

      <div class="offline-indicator" id="offlineIndicator">
        <strong>Connection Lost:</strong> Unable to communicate with server.
        Attempting to reconnect...
      </div>

      <div class="task-panel" id="taskPanel" style="display: none">
        <h3>Liveness Verification Tasks</h3>
        <div id="taskContent">
          <div class="task-progress">
            <span id="taskProgress">Ready to start</span>
            <span class="task-timer" id="taskTimer">30s</span>
          </div>
          <div class="task-instruction" id="taskInstruction">
            Click "Start Liveness Test" to begin
          </div>
          <div class="task-list" id="taskList"></div>
          <div id="taskResult" style="display: none"></div>
          <div
            id="antiSpoofResult"
            class="anti-spoof-panel"
            style="display: none"
          ></div>
          <div
            id="finalResult"
            class="final-result"
            style="display: none"
          ></div>
        </div>
      </div>

      <div class="status-panel">
        <h3>Detection Status</h3>
        <div id="statusItems">
          <div class="status-item">
            <span class="status-label">Status:</span>
            <span class="status-value" id="detectionStatus">No detection</span>
          </div>
          <div class="status-item">
            <span class="status-label">Confidence:</span>
            <span class="status-value" id="confidenceValue">0.00</span>
          </div>
          <div class="status-item">
            <span class="status-label">Result:</span>
            <span class="status-value" id="resultValue">-</span>
          </div>
          <div class="status-item">
            <span class="status-label">Blinks:</span>
            <span class="status-value" id="blinkValue">0</span>
          </div>
          <div class="status-item">
            <span class="status-label">Head Direction:</span>
            <span class="status-value" id="headDirection">Forward</span>
          </div>
        </div>

        <div class="confidence-bar">
          <div
            class="confidence-fill"
            id="confidenceFill"
            style="width: 0%"
          ></div>
        </div>

        <div
          id="antiSpoofSummary"
          class="anti-spoof-panel"
          style="display: none"
        >
          <h4>Anti-Spoof Summary</h4>
          <div id="antiSpoofDetails"></div>
        </div>

        <div id="errorMessage" class="error" style="display: none"></div>
      </div>
    </div>

    <script>
      const API_BASE_URL = "http://15.206.8.45";
     //    const API_BASE_URL = 'http://localhost:5000';

      const API_KEY = "dz_live_2024_secure_api_key_xyz789";

      let isStreaming = false;
      let statusInterval;
      let taskInterval;
      let sessionId = null;
      let mediaStream = null;
      let video = null;
      let canvas = null;
      let ctx = null;
      let processingFrame = false;

      // Initialize video elements
      function initializeVideoElements() {
        video = document.getElementById("cameraVideo");
        canvas = document.getElementById("canvas");
        ctx = canvas.getContext("2d");
      }

      // Create new session using new API
      async function createSession() {
        try {
          const response = await fetch(`${API_BASE_URL}/session`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              // Remove X-API-Key for session creation
            },
            body: JSON.stringify({ action: "create" }),
          });

          const data = await response.json();
          if (data.success) {
            sessionId = data.session_id;
            document.getElementById("sessionId").textContent = sessionId;
            document.getElementById("sessionInfo").style.display = "block";
            document.getElementById("sessionStatus").textContent = "Active";
            console.log("Session created:", sessionId);
            return true;
          } else {
            showMessage(data.message, "error");
            return false;
          }
        } catch (error) {
          console.error("Error creating session:", error);
          showMessage("Failed to create session: " + error.message, "error");
          return false;
        }
      }

      // End current session using new API
      async function endSession() {
        if (sessionId) {
          try {
            await fetch(`${API_BASE_URL}/session`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-API-Key": API_KEY,
              },
              body: JSON.stringify({ action: "end", session_id: sessionId }),
            });
            console.log("Session ended:", sessionId);
          } catch (error) {
            console.error("Error ending session:", error);
          }

          sessionId = null;
          document.getElementById("sessionId").textContent = "Not connected";
          document.getElementById("sessionStatus").textContent = "Inactive";
          document.getElementById("sessionInfo").style.display = "none";
        }
      }

      // Get user media (camera access)
      async function getUserMedia() {
        try {
          // Check if getUserMedia is supported
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error("Camera access not supported by this browser");
          }

          const constraints = {
            video: {
              width: { ideal: 640 },
              height: { ideal: 480 },
              facingMode: "user",
            },
            audio: false,
          };

          console.log("Requesting camera access...");
          mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = mediaStream;

          // Wait for video to load
          return new Promise((resolve, reject) => {
            video.onloadedmetadata = () => {
              console.log("Video metadata loaded");
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              document.getElementById("cameraAccess").textContent = "Granted";
              resolve(true);
            };

            video.onerror = (error) => {
              console.error("Video error:", error);
              reject(new Error("Failed to load video"));
            };

            // Timeout after 10 seconds
            setTimeout(() => {
              reject(new Error("Camera access timeout"));
            }, 10000);
          });
        } catch (error) {
          console.error("Error accessing camera:", error);
          document.getElementById("cameraAccess").textContent = "Denied";

          let errorMessage = "Camera access denied. ";
          if (error.name === "NotAllowedError") {
            errorMessage += "Please grant camera permissions and try again.";
          } else if (error.name === "NotFoundError") {
            errorMessage += "No camera found on this device.";
          } else if (error.name === "NotReadableError") {
            errorMessage += "Camera is being used by another application.";
          } else {
            errorMessage += error.message;
          }

          showMessage(errorMessage, "error");
          return false;
        }
      }

      // Enhanced connection management
      let connectionRetryCount = 0;
      let maxRetryAttempts = 5;
      let retryDelay = 2000; // Start with 2 seconds
      let lastSuccessfulRequest = Date.now();
      let consecutiveErrors = 0;

      // Capture frame from video and send to server
      async function captureAndProcessFrame() {
        if (!sessionId || !video || !canvas || processingFrame) {
          return;
        }

        try {
          processingFrame = true;

          // Check if video is ready
          if (video.readyState !== video.HAVE_ENOUGH_DATA) {
            return;
          }

          // Draw current video frame to canvas
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

          // Convert canvas to base64
          const frameData = canvas.toDataURL("image/jpeg", 0.6);

          // Create fetch with timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout

          // Send frame to server
          const response = await fetch(`${API_BASE_URL}/process_frame`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-API-Key": API_KEY,
            },
            body: JSON.stringify({
              session_id: sessionId,
              frame: frameData,
            }),
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const result = await response.json();

          if (result.error) {
            console.error("Server error:", result.error);

            // Handle session-related errors
            if (
              result.error.includes("Invalid session_id") ||
              result.error.includes("Session expired") ||
              result.error.includes("Session inactive")
            ) {
              await stopCamera();
              showMessage(
                "Session expired or invalid. Please restart camera.",
                "error"
              );
              return;
            }

            // Handle server busy errors
            if (result.error.includes("Server busy")) {
              console.log("Server busy, slowing down requests...");
              await new Promise((resolve) => setTimeout(resolve, 1000));
              return;
            }

            consecutiveErrors++;
            if (consecutiveErrors > 5) {
              showOfflineIndicator();
            }
          } else {
            updateStatusDisplay(result);
            hideOfflineIndicator();
            lastSuccessfulRequest = Date.now();
            consecutiveErrors = 0;
            connectionRetryCount = 0; // Reset retry count on success
          }
        } catch (error) {
          console.error("Error processing frame:", error);
          consecutiveErrors++;

          if (error.name === "AbortError") {
            console.log("Request timed out");
            showMessage("Request timed out. Retrying...", "warning");
          } else {
            console.log("Network error, showing offline indicator");
          }

          showOfflineIndicator();

          // Implement exponential backoff for retries
          if (connectionRetryCount < maxRetryAttempts) {
            connectionRetryCount++;
            const delay = Math.min(
              retryDelay * Math.pow(2, connectionRetryCount - 1),
              30000
            ); // Max 30 seconds
            console.log(
              `Retrying in ${
                delay / 1000
              } seconds... (${connectionRetryCount}/${maxRetryAttempts})`
            );

            setTimeout(() => {
              if (isStreaming && sessionId) {
                console.log("Attempting to reconnect...");
                hideOfflineIndicator();
              }
            }, delay);
          } else {
            console.log("Max retry attempts reached. Please refresh the page.");
            showMessage(
              "Connection lost. Please refresh the page or restart camera.",
              "error"
            );
          }
        } finally {
          processingFrame = false;
        }
      }

      // Enhanced offline indicator management
      function showOfflineIndicator() {
        const indicator = document.getElementById("offlineIndicator");
        if (indicator) {
          indicator.style.display = "block";
          indicator.innerHTML = `
                    <strong>Connection Issues:</strong> 
                    ${
                      connectionRetryCount > 0
                        ? `Retry ${connectionRetryCount}/${maxRetryAttempts}`
                        : "Attempting to reconnect..."
                    }
                `;
        }
      }

      function hideOfflineIndicator() {
        const indicator = document.getElementById("offlineIndicator");
        if (indicator) {
          indicator.style.display = "none";
        }
      }

      // Enhanced session validation
      async function validateAndRecoverSession() {
        if (!sessionId) return false;

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);

          const response = await fetch(`${API_BASE_URL}/session`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-API-Key": API_KEY,
            },
            body: JSON.stringify({
              action: "status",
              session_id: sessionId,
            }),
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();

          if (data.success && data.active) {
            return true;
          } else {
            console.log("Session invalid, creating new one...");
            sessionId = null;
            return await createSession();
          }
        } catch (error) {
          console.error("Session validation error:", error);
          return false;
        }
      }

      // Periodic connection health check
      let healthCheckInterval = null;

      function startHealthCheck() {
        if (healthCheckInterval) {
          clearInterval(healthCheckInterval);
        }

        healthCheckInterval = setInterval(async () => {
          if (!isStreaming || !sessionId) return;

          // If we haven't had a successful request in 30 seconds, check health
          if (Date.now() - lastSuccessfulRequest > 30000) {
            try {
              const response = await fetch(`${API_BASE_URL}/health`, {
                method: "GET",
                signal: AbortSignal.timeout(5000),
              });

              if (response.ok) {
                console.log("Health check passed");
                lastSuccessfulRequest = Date.now();
                hideOfflineIndicator();
              } else {
                throw new Error("Health check failed");
              }
            } catch (error) {
              console.error("Health check failed:", error);
              showOfflineIndicator();
            }
          }
        }, 15000); // Check every 15 seconds
      }

      function stopHealthCheck() {
        if (healthCheckInterval) {
          clearInterval(healthCheckInterval);
          healthCheckInterval = null;
        }
      }

      // Capture and process frame every 100ms
      // statusInterval = setInterval(captureAndProcessFrame, 1000); // Reduced frequency
      // startHealthCheck(); // Start health monitoring

      async function startCamera() {
        try {
          console.log("Starting camera...");
          initializeVideoElements();

          // Validate existing session or create new one
          if (sessionId && !(await validateAndRecoverSession())) {
            console.log("Session validation failed");
            return;
          }

          if (!sessionId) {
            console.log("Creating new session...");
            if (!(await createSession())) {
              return;
            }
          }

          // Get camera access
          if (!(await getUserMedia())) {
            return;
          }

          // Start streaming
          isStreaming = true;
          document.getElementById("cameraVideo").style.display = "block";
          document.getElementById("sessionInfo").style.display = "block";

          // Start intervals
          statusInterval = setInterval(captureAndProcessFrame, 1000); // Reduced frequency
          startHealthCheck(); // Start health monitoring

          showMessage("Camera started successfully", "success");
          console.log("Camera started successfully");
        } catch (error) {
          console.error("Error starting camera:", error);
          showMessage("Error starting camera: " + error.message, "error");
          await endSession();
        }
      }

      // Update stopCamera to cleanup health check
      async function stopCamera() {
        try {
          console.log("Stopping camera...");

          // Stop intervals and health check
          if (statusInterval) {
            clearInterval(statusInterval);
            statusInterval = null;
          }
          if (taskInterval) {
            clearInterval(taskInterval);
            taskInterval = null;
          }
          stopHealthCheck();

          // Stop media stream
          if (mediaStream) {
            mediaStream.getTracks().forEach((track) => {
              track.stop();
              console.log("Stopped track:", track.kind);
            });
            mediaStream = null;
          }

          // Clear video source
          if (video) {
            video.srcObject = null;
          }

          // Hide video
          document.getElementById("cameraVideo").style.display = "none";
          document.getElementById("videoFeed").style.display = "none";
          document.getElementById("cameraAccess").textContent = "Not granted";

          isStreaming = false;

          // End session
          await endSession();

          // Reset status
          resetStatus();
          hideOfflineIndicator();
          showMessage("Camera stopped successfully", "success");

          // Reset connection state
          connectionRetryCount = 0;
          consecutiveErrors = 0;
        } catch (error) {
          console.error("Error stopping camera:", error);
          showMessage("Error stopping camera", "error");
        }
      }

      async function startLivenessTask() {
        if (!sessionId) {
          showMessage("No active session. Please start camera first.", "error");
          return;
        }

        try {
          const response = await fetch(
            `${API_BASE_URL}/liveness/${sessionId}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-API-Key": API_KEY,
              },
              body: JSON.stringify({ action: "start" }),
            }
          );
          const data = await response.json();

          if (data.success) {
            document.getElementById("taskPanel").style.display = "block";
            updateTaskDisplay(data.session_status);

            // Start task status polling
            taskInterval = setInterval(updateTaskStatus, 200);

            showMessage(data.message, "success");
          } else {
            showMessage(data.message, "error");
          }
        } catch (error) {
          showMessage("Error starting liveness task: " + error, "error");
        }
      }

      async function resetTaskSession() {
        if (!sessionId) {
          showMessage("No active session.", "error");
          return;
        }

        try {
          const response = await fetch(
            `${API_BASE_URL}/liveness/${sessionId}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-API-Key": API_KEY,
              },
              body: JSON.stringify({ action: "reset" }),
            }
          );
          const data = await response.json();

          if (data.success) {
            document.getElementById("taskPanel").style.display = "none";
            if (taskInterval) {
              clearInterval(taskInterval);
              taskInterval = null;
            }
            showMessage(data.message, "success");
          }
        } catch (error) {
          showMessage("Error resetting task session: " + error, "error");
        }
      }

      async function updateTaskStatus() {
        if (!sessionId) return;

        try {
          const response = await fetch(
            `${API_BASE_URL}/liveness/${sessionId}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-API-Key": API_KEY,
              },
              body: JSON.stringify({ action: "status" }),
            }
          );
          const data = await response.json();

          if (data.error) {
            console.error("Task status error:", data.error);
            return;
          }

          updateTaskDisplay(data);

          // Stop polling if session is complete
          if (!data.active && taskInterval) {
            clearInterval(taskInterval);
            taskInterval = null;
          }
        } catch (error) {
          console.error("Error getting task status:", error);
        }
      }

      function updateStatusDisplay(result) {
        const statusElement = document.getElementById("detectionStatus");
        const confidenceElement = document.getElementById("confidenceValue");
        const resultElement = document.getElementById("resultValue");
        const confidenceFill = document.getElementById("confidenceFill");
        const statusItems = document.querySelectorAll(".status-item");

        // Update text values
        statusElement.textContent = result.status;
        confidenceElement.textContent = result.confidence.toFixed(2);
        resultElement.textContent = result.is_real ? "REAL FACE" : "FAKE FACE";

        // Update confidence bar
        const confidencePercent = result.confidence * 100;
        confidenceFill.style.width = confidencePercent + "%";

        // Update colors based on result
        if (result.is_real && result.confidence > 0.5) {
          confidenceFill.className = "confidence-fill real-confidence";
          statusItems.forEach((item) => {
            item.classList.remove("fake");
            item.classList.add("real");
          });
        } else {
          confidenceFill.className = "confidence-fill fake-confidence";
          statusItems.forEach((item) => {
            item.classList.remove("real");
            item.classList.add("fake");
          });
        }

        // Update additional fields
        document.getElementById("blinkValue").textContent = result.blinks || 0;
        document.getElementById("headDirection").textContent = result.head_pose
          ? result.head_pose.direction
          : "Forward";

        // Update anti-spoof summary if available
        if (result.anti_spoof_summary) {
          updateAntiSpoofSummary(result.anti_spoof_summary);
        }

        // Update task display if task session data is available
        if (result.task_session) {
          updateTaskDisplay(result.task_session);
        }
      }

      function updateAntiSpoofSummary(summary) {
        const antiSpoofSummary = document.getElementById("antiSpoofSummary");
        const antiSpoofDetails = document.getElementById("antiSpoofDetails");

        if (summary.total_processed > 0) {
          antiSpoofSummary.style.display = "block";

          // Update class based on status
          antiSpoofSummary.className = "anti-spoof-panel";
          if (summary.status === "Real") {
            antiSpoofSummary.classList.add("anti-spoof-passed");
          } else {
            antiSpoofSummary.classList.add("anti-spoof-failed");
          }

          antiSpoofDetails.innerHTML = `
                    <strong>Real Predictions:</strong> ${
                      summary.real_count
                    } (${summary.real_percentage.toFixed(1)}%)<br>
                    <strong>Fake Predictions:</strong> ${
                      summary.fake_count
                    } (${summary.fake_percentage.toFixed(1)}%)<br>
                    <strong>Total Processed:</strong> ${
                      summary.total_processed
                    }<br>
                    <strong>Overall Status:</strong> ${summary.status}
                `;
        } else {
          antiSpoofSummary.style.display = "none";
        }
      }

      function updateTaskDisplay(taskStatus) {
        const taskPanel = document.getElementById("taskPanel");
        const taskProgress = document.getElementById("taskProgress");
        const taskTimer = document.getElementById("taskTimer");
        const taskInstruction = document.getElementById("taskInstruction");
        const taskList = document.getElementById("taskList");
        const taskResult = document.getElementById("taskResult");
        const antiSpoofResult = document.getElementById("antiSpoofResult");
        const finalResult = document.getElementById("finalResult");

        if (!taskStatus.active && !taskStatus.result) {
          // No active session
          taskPanel.className = "task-panel";
          taskProgress.textContent = "Ready to start";
          taskTimer.textContent = "30s";
          taskInstruction.textContent = 'Click "Start Liveness Test" to begin';
          taskList.innerHTML = "";
          taskResult.style.display = "none";
          antiSpoofResult.style.display = "none";
          finalResult.style.display = "none";
          return;
        }

        if (taskStatus.active) {
          // Active session
          taskPanel.className = "task-panel task-active";
          taskProgress.textContent = `Task ${taskStatus.completed_tasks + 1}/${
            taskStatus.total_tasks
          }`;
          taskTimer.textContent = `${Math.ceil(taskStatus.time_remaining)}s`;

          if (taskStatus.current_task) {
            taskInstruction.textContent = taskStatus.current_task.description;
          } else {
            taskInstruction.textContent = "Preparing next task...";
          }

          // Update task list
          taskList.innerHTML = "";
          if (taskStatus.tasks) {
            taskStatus.tasks.forEach((task, index) => {
              const taskItem = document.createElement("div");
              taskItem.className = "task-item";

              if (index < taskStatus.completed_tasks) {
                taskItem.classList.add("completed");
              } else if (index === taskStatus.completed_tasks) {
                taskItem.classList.add("current");
              }

              taskItem.textContent = task;
              taskList.appendChild(taskItem);
            });
          }

          taskResult.style.display = "none";
          antiSpoofResult.style.display = "none";
          finalResult.style.display = "none";
        } else if (taskStatus.result) {
          // Session completed - check both task completion AND anti-spoof validation
          const tasksPassed = taskStatus.result.passed;
          const antiSpoofPassed = taskStatus.result.anti_spoof_passed;
          const finalPassed = taskStatus.result.final_result; // This considers both validations

          // Set panel class based on final result, not just tasks
          taskPanel.className = `task-panel ${
            finalPassed ? "task-completed" : "task-failed"
          }`;

          taskProgress.textContent = "Session Complete";
          taskTimer.textContent = `${taskStatus.result.duration.toFixed(1)}s`;

          // Update instruction based on final result
          if (finalPassed) {
            taskInstruction.textContent = "Liveness Verification PASSED!";
          } else if (!tasksPassed) {
            taskInstruction.textContent = "Liveness Tasks FAILED!";
          } else if (!antiSpoofPassed) {
            taskInstruction.textContent = "Anti-Spoof Validation FAILED!";
          } else {
            taskInstruction.textContent = "Liveness Verification FAILED!";
          }

          // Show task completion result
          taskResult.style.display = "block";
          taskResult.innerHTML = `
                    <strong>Tasks Completed:</strong> ${
                      taskStatus.result.completed
                    }/${taskStatus.result.total}<br>
                    <strong>Task Success Rate:</strong> ${(
                      taskStatus.result.success_rate * 100
                    ).toFixed(1)}%<br>
                    <strong>Tasks Status:</strong> ${
                      tasksPassed ? "PASSED" : "FAILED"
                    }
                `;

          // Show anti-spoof validation result
          if (taskStatus.result.anti_spoof_validation) {
            antiSpoofResult.style.display = "block";
            const validation = taskStatus.result.anti_spoof_validation;

            antiSpoofResult.className = `anti-spoof-panel ${
              antiSpoofPassed ? "anti-spoof-passed" : "anti-spoof-failed"
            }`;
            antiSpoofResult.innerHTML = `
                        <h4>Anti-Spoof Validation</h4>
                        <strong>Status:</strong> ${
                          antiSpoofPassed ? "PASSED" : "FAILED"
                        }<br>
                        <strong>Real Predictions:</strong> ${
                          validation.real_predictions
                        }/${
              validation.total_predictions
            } (${validation.real_percentage.toFixed(1)}%)<br>
                        <strong>Average Confidence:</strong> ${validation.average_confidence.toFixed(
                          2
                        )}<br>
                        <div class="validation-details">
                            <strong>Reason:</strong> ${validation.reason}
                        </div>
                    `;
          } else {
            antiSpoofResult.style.display = "none";
          }

          // Show final result
          finalResult.style.display = "block";
          finalResult.className = `final-result ${
            finalPassed ? "passed" : "failed"
          }`;
          finalResult.textContent = finalPassed
            ? "FINAL RESULT: LIVE PERSON VERIFIED"
            : "FINAL RESULT: VERIFICATION FAILED";

          taskList.innerHTML = "";
        }
      }

      function resetStatus() {
        document.getElementById("detectionStatus").textContent = "No detection";
        document.getElementById("confidenceValue").textContent = "0.00";
        document.getElementById("resultValue").textContent = "-";
        document.getElementById("confidenceFill").style.width = "0%";

        const statusItems = document.querySelectorAll(".status-item");
        statusItems.forEach((item) => {
          item.classList.remove("real", "fake");
        });
      }

      function showMessage(message, type) {
        const errorDiv = document.getElementById("errorMessage");
        errorDiv.textContent = message;
        errorDiv.className = type === "error" ? "error" : "success";
        errorDiv.style.display = "block";

        setTimeout(() => {
          errorDiv.style.display = "none";
        }, 5000);
      }

      // Cleanup on page unload
      window.addEventListener("beforeunload", async () => {
        await stopCamera();
      });

      // Handle page visibility changes
      document.addEventListener("visibilitychange", () => {
        if (document.hidden && isStreaming) {
          // Page is hidden, slow down processing
          if (statusInterval) {
            clearInterval(statusInterval);
            statusInterval = setInterval(captureAndProcessFrame, 500); // Slower when hidden
          }
        } else if (!document.hidden && isStreaming) {
          // Page is visible, resume normal processing
          if (statusInterval) {
            clearInterval(statusInterval);
            statusInterval = setInterval(captureAndProcessFrame, 100); // Back to ~10 FPS
          }
        }
      });

      // Check browser support on page load
      window.addEventListener("DOMContentLoaded", () => {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          showMessage(
            "This browser does not support camera access. Please use a modern browser like Chrome, Firefox, or Safari.",
            "error"
          );
        } else {
          console.log("Browser supports camera access");
        }
      });

      // Add success message styling
      const style = document.createElement("style");
      style.textContent = `
            .success {
                background-color: #e8f5e8;
                color: #2e7d32;
                padding: 10px;
                border-radius: 5px;
                margin-top: 10px;
                border-left: 4px solid #4caf50;
            }
        `;
      document.head.appendChild(style);
    </script>
  </body>
</html>
